function [SST_Out] = fast_interpolate_SST_linear( weights, locations, SST_In)
% fast_interpolate_SST_linear - interpolate to regridded orbit - PCC
%  
% This function will regrid an input array based on a set of weights and
% locations. For each pixel location of the output array, the locations
% identify the pixels in the input array contributing to the SST at the
% output location and the weights, how much to weight the input SST at
% those locations. 
%
% weights and locations are generated by another script. The idea is to do
% it for entire orbits. Since the relationship between latitudes and
% longitudes remains the same for all orbits, the weights and locations
% should be the same.
%
% INPUT
%   weights - 3d array of weights, the 1st dimension is for the number of
%    weights at a given pixel location. These weights correspond to the
%    weights to use in regridding from the input pixels contributing to the
%    output pixel at an output location.
%   locations - the locations of the input pixels contributing to the
%    output pixel at each output location. The location number are the
%    index of the input array as a 1d vector.
%   SST_In - is the SST of the input field.
%
% OUTPUT
%   SST_Out - is the regridded SST.
%
% EXAMPLE: 
%   fi_orbit = '/Volumes/Aqua-1/Fronts/MODIS_Aqua_L2/SST/2010/07/AQUA_MODIS.20100701T004317.L2.SST.nc4';
%   SST_In = ncread(fi_orbit, 'SST_In');
%   [SST_Out] = fast_interpolate_SST_linear( weights, locations, SST_In);
%

[nElements, nScans] = size(SST_In);
[nMax, mElements, mScans] = size(weights);

nMax = 6;

% % % % Normalize the weights array.
% % % 
% % % kMax = nMax;
% % % 
% % % norm_factor = sum(weights, 1, 'omitnan');
% % % norm_factor = sum(weights(1:kMax,:,:), 1, 'omitnan');

% % % for i=1:nMax
% % for i=1:kMax
% %     weights(i,:,:) = weights(i,:,:) ./ norm_factor;
% % end

% Check number of elements/scan line; should be the same for weights and sst.

if mElements > nElements
    fprintf('\n\n****************\nNumber of weight elements/scan (%i) is not equal to the number of SST elements/scans (%i).\n****************\n\n ', mElements, nElements)
    
    regridded_sst = [];
    return
end

% Make sure that there are more weight scan lines than SST scan lines.

if mScans < nScans
    fprintf('\n\n****************\nNumber of weight scans (%i) is less than the number of SST scans (%i).\n****************\n\n ', mScans, nScans)
    
    regridded_sst = [];
    return
end

% % % % Truncate weights array to same number of scan lines as SST array.
% % % 
% % % weights = weights(:,:,1:nScans);

% Now regrid.

SST_Out = zeros([nElements, nScans]);

% % % for iC=1:kMax
% % %     weights_temp = weights(iC,:,:);
% % %     locations_temp = locations(iC,:,:);
% % %     
% % %     non_zero_weights = find(weights_temp ~= 0);
% % %     tt = locations_temp(non_zero_weights);
% % %     
% % %     SST_temp = zeros([nElements, nScans]);
% % % %     SST_temp(non_zero_weights(isnan(tt)==0)) = weights_temp(non_zero_weights(isnan(tt)==0)) .* SST_In(tt(isnan(tt)==0));
% % % 
% % %     mm = find( (isnan(tt)==0) & (tt~=0));
% % %     SST_temp(non_zero_weights(mm)) = weights_temp(non_zero_weights(mm)) .* SST_In(tt(mm));
% % %     
% % %     SST_Out = SST_Out + SST_temp;
% % % end

for iC=1:nMax
    weights_temp = squeeze(weights(iC,:,:));
    locations_temp = squeeze(locations(iC,:,:));
    
    good_weights = find( (weights_temp ~= 0) & (isnan(weights_temp) == 0) & (locations_temp ~= 0));
    tt = locations_temp(good_weights);
    
    SST_Out(good_weights) = SST_Out(good_weights) + SST_In(tt) .* weights_temp(good_weights);
end
