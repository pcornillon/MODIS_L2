% generate_separations_and_angles - Generate the separation fields and angles needed to determine gradient east and north - PCC
%
% Canonical separations and angles are generated for MODIS in a three step
% process. The input to the algorithm is a set of complete orbits
% generated by build_and_fix_orbits, which saves the regridded lat, lon
% and SST. The script does the following for each orbit with more than 40270
% scan lines in the specified year. The scan line threshold was used to make
% sure that the resulting orbital length (number of scan lines) would be
% long enough. Fiftyfour 40,270 scan line orbits were used to generate this
% set of along-scan, along-track and scan line angle orbital arrays.
%
% The overall idea is that the separations in the along-scan and along-track
% directions are very similar for all scan lines, the only difference being
% in a slight scale factor due to the height of the satellite and anomalies
% resulting from land. Steps 1 and 2 below get a pretty smoothed version of
% the separation fields. Step 3 obtains a final smoothed version and
% addresses variations due to satellite height.
%
% STEP 1:
%
% For each orbit the script determines the separation of the regridded
% pixels in the along-scan and along-track directions. It does this for a
% step of 10 pixels in each direction. Because of the 10 pixel step used,
% it needs to fill in the data at the end of each scan line. This is done
% by extrapolating from the last two pixels on each scan line to the 5th
% pixel, 4th,... 1st pixel on each end of the line. In the along-track
% direction, the last separation is simply repeated 5 times since the
% separation changes very slowly with along-track direction. These arrays
% are averaged in the along-track direction and then input values that
% differ by more than Threshold(2) (0.3 km) from the average scan line are
% set to to nan. The resulting 'cleaned-up' separation arrays are then
% averaged over all orbits. The variance at every pixel location is also
% obtained.
%
% For each orbit the azimuthal angle in the along-scan direction is
% determined at each pixel location. This is done for separations between
% the i+2 pixel and i pixel to reduce the noise a bit. The angle arrays
% are then averaged over all orbits. The mean azimuthal angles are
% smoothed with an 11-point median filter, converted to angles
% counter-clockwise from east and recast to a range of 0 to 360 degrees.
% The variance of the angles is also obtained at every pixel location.
%
% The main output fields of this step are arrays of along-scan separations,
% along-track separations and the angle of the scan line measured
% counter-clockwise from east. The scan direction is determined in the
% context of the direction of the scan--if the scan is east-to-west, the
% angle would 180 degrees, west-to-east, 0 degrees and south-to-north 90
% degrees. These fields and associated variance fields are saved in a file
% called: 'mean_seps_and_angles_pass_1.mat'. Also saved in this file is the
% nadir track of one of the input files. The latitudes should be very
% nearly the same for all files, the longitudes will be shifted based on
% the ascending equatorial crossing.
%
% In addition to the averaged fields, the cleaned-up along-scan and along-
% track separations and scan line angle fields are written to a file for
% each orbit. These are used in Step 2.
%
% STEP 2:
%
% For each orbit the script loads the .mat file written in Step 1 for that
% orbit. It then averages the along-scan and along-track separation arrays
% in the along-track to obtain a mean scan line of separations for each pixel.
% The scan lines are replicated to produce an array the size of the input
% array. Two tests are then performed on the input array: 1) all elements
% of the input array that differ from the reconstructed array by more than
% Threshold(2) (0.3 km) are set to nan, and 2) all elements of the input
% value that differ from the mean array (obtained in Step 1 by average
% cleaned-up arrays over all orbits by more than Threshold(3) (0.02 km) are
% set to nan. The resulting newly cleaned-up separation arrays are again
% averaged over all orbits. The variance at every pixel location is also
% obtained.
%
% The main output fields of this step are arrays of along-scan separations
% and along-track separations. These fields and associated variance fields
% are saved along with the angle information from Step 1 in a file called:
% 'mean_seps_and_angles_pass_2.mat'. Also saved in this file is the nadir
% track saved in Step 1.
%
% STEP 3:
%
% The along-scan and along-track separations averaged over all orbits in
% Step 2 are averaged in the along-track direction, excluding a manually
% selected set of bad scans. This average is then fit to each individual
% scan line in the averaged arrays from Step 2 to determine the scale
% factor needed to adjust for satellite height--as the satellite moves up
% and down along its orbit the along-scan separations change appreciably.
% The scale factor vectors with a value for each scan line are then
% smoothed with a 1000 scan line guassian filter. The large number of scan
% lines used to smooth assumes that the orbital altitude changes slowly.
%
% The mean along-scan separation and along-track separation (averaged over
% the entire canonical orbit), together with the factors are written out as
% a netCDF file with the latitude, longitude, scan-angle, reconstructed
% along-scan and reconstructed along-track arrays. The reconstruction is
% the averaged scan line separations multipled by the scan line factor
% vector.
%
%               VARIABLES
%
% mean_az - the azimuthal angle of the scan line measured clockwise from
%  north. The direction of the scan line is taken as positive in the
%  direction in which the sensor is scanning.
%
% as_angle - the counter-clockwise angle the scan line makes relative to
%  east at each pixel location. The direction of the scan line is taken as
%  the scan direction, so if the sensor is scaning east-to-west, the angle
%  would be -180 degrees, west-to-east, 0 degrees, south-to-north 90 degrees.
%
% mean_az_final - as_angle smoothed with an 11 point moving median filter in
%  the along-scan direction.
%
% mean_sas - separations in the along-scan direction averaged over a number
%  of orbits. The orbits were constructed so that the location of a pixel
%  in the orbit is at very nearly the same location for all orbits of a
%  given length. There are in fact two lengths of orbits differing by 10
%  scan lines. I may fix this by buffering one end or the other the orbit
%  for the shorter ones.
% mean_sat - separations in the along-track direction averaged over a number of orbits.
%

base_dir_ancillary_data = '/Users/petercornillon/Dropbox/Data/Support_data_for_MODIS_L2_Corrections_1/';
% base_dir_orbital_data = '/Volumes/Aqua-1/Fronts/MODIS_Aqua_L2/SST/2010/';
base_dir_orbital_data = ['/Volumes/MODIS_L2_modified/OBPG/SST/2011/'];

base_dir_output_data = '/Users/petercornillon/Dropbox/Data/MODIS_L2/';

% Does the output netCDF file exist. If so stop this run. Note that the
% filename but be completely specified; i.e., ~/Dropbox... fails when
% netCDF tries to open it.

output_filename = [base_dir_output_data '/Data/Separation_and_Angle_Arrays_79Sa.n4'];

if exist(output_filename) == 2
    fprintf('\n ***********************************************************\n Separation_and_Angle_Arrays.n4 Already Exists *************\n ***********************************************************\n\n')
    what_to_do = input('Enter d to delete the file and continue; any other key to exit: ', 's');
    if strcmp( what_to_do, 'd')
        eval(['! rm ' output_filename])
    else
        return
    end
end

%% Passed checks on input parameters. Open a diary file for this run.

logs_dir = [base_dir_output_data 'Logs/'];

Diary_File = [logs_dir 'generate_separations_and_angles_' strrep(num2str(now), '.', '_') '.txt'];
diary(Diary_File)

tic_build_start = tic;

%% Intialize control parameters for this file.

do_first_iteration = 1;
do_second_iteration = 1;
do_final_smoothing = 1;
write_netCDF_file = 1;

%% Start processing

% Where the complete orbits are; months to use.

% month_start = 1;
% month_end = 1;
month_start = 2;
month_end = 2;

month_list_temp = dir(base_dir_orbital_data);

% Get rid of . and .. directories.

jfn = 0;
for ifn=1:length(month_list_temp)
    if strcmp(month_list_temp(ifn).name(1), '.') == 0
        jfn = jfn + 1;
        month_list(jfn) = month_list_temp(ifn);
    end
end

%% Do first iteration over separations and only iteration over angles.

seps_and_angles_filename_1 = [base_dir_output_data 'Data/mean_seps_and_angles_pass_1.mat'];

if do_first_iteration
    
    fprintf('\n ***********************************************************\n Doing First iteration *************************************\n ***********************************************************\n\n')
    
    scan_sep_threshold = [5.5 0.3 0];
    track_sep_threshold = [1.5 0.3 0];
    
    iFile = 0;
    
    for iMonth=month_start:month_end
        
        % Get the list of orbits (files) for this month.
        
        file_list = dir([base_dir_orbital_data month_list(iMonth).name '/Aqua*.nc4']);
        
        % Some months in 2011 do not have complete orbits at this point.
        
        if length(file_list) > 0
            
            % Loop over file_list--orbits.
            
            for jFile=1:length(file_list)
                
                fi_orbit = [base_dir_orbital_data month_list(iMonth).name '/' file_list(jFile).name];
                
                % Get the dimensions of the lat and lon arrays and skip if
                % less than 40270; want to generate separations for the
                % longest orbits available, orbits are either 40261 or
                % 40271.
                
                finfo = ncinfo(fi_orbit);
                dims(1) = finfo.Dimensions(1).Length;
                dims(2) = finfo.Dimensions(2).Length;
                
                fprintf('jFile=%i) Dimensions for arrays on this orbit are: %i, %i \n', jFile, dims)
                
                if dims(2) > 40270
                    
                    fprintf('Processing %s.\n\n', fi_orbit)
                    
                    iFile = iFile + 1;
                    
                    %% Read in the lat and lon for this orbit.
                    
                    latitude = ncread( fi_orbit, 'regridded_latitude');
                    longitude = ncread( fi_orbit, 'regridded_longitude');
                    
                    %% Get along-track and along-scan separation of pixels in kilometers
                    
                    % Shift lat and lon arrays in the along-scan direction by
                    % 10 points and then difference. This will result in new
                    % arrays that are 10 pixels less in the along-scan
                    % direction with values corresponding to 10 pixel
                    % separation. This should reduce some of the jiggle.
                    
                    lat_along_scan_sep_temp = (latitude(11:end,:) - latitude(1:end-10,:)) * 111;
                    lon_along_scan_sep_temp = (longitude(11:end,:) - longitude(1:end-10,:)) .* cosd(latitude(1:end-10,:)) * 111;
                    
                    % Augment the arrays back to the original size. dummy
                    % values used to be lxx_along_xxxx_sep_x_10
                    
                    lat_along_scan_sep = augment_arrays( 1, lat_along_scan_sep_temp, [], [-1 -1]);
                    lon_along_scan_sep = augment_arrays( 1, lon_along_scan_sep_temp, [], [-1 -1]);
                    
                    clear lat_along_scan_sep_temp lon_along_scan_sep_temp
                    
                    % Repeat for along_track...
                    
                    lat_along_track_sep_temp = (latitude(:,11:end) - latitude(:,1:end-10)) * 111;
                    lon_along_track_sep_temp = (longitude(:,11:end) - longitude(:,1:end-10)) .* cosd(latitude(:,1:end-10)) * 111;
                    
                    % Augment the arrays back to the original size.
                    
                    lat_along_track_sep = augment_arrays( 2, lat_along_track_sep_temp, [], [-1 -1]);
                    lon_along_track_sep = augment_arrays( 2, lon_along_track_sep_temp, [], [-1 -1]);
                    
                    clear lat_along_track_sep_temp lon_along_track_sep_temp
                    
                    % At this point we have the lat and lon separation
                    % in kmsbetween adjacent pixels in the along-scan
                    %  and along-track directions.
                    
                    % Separations of pixels along-scan and along-track.
                    
                    along_scan_sep = sqrt(lat_along_scan_sep.^2 + lon_along_scan_sep.^2);
                    along_track_sep = sqrt(lat_along_track_sep.^2 + lon_along_track_sep.^2);
                    
                    % Get rid of obvious outliers.
                    
                    along_scan_sep = cleanup_arrays( along_scan_sep, [], scan_sep_threshold);
                    along_track_sep = cleanup_arrays( along_track_sep, [], track_sep_threshold);
                    
                    if iFile == 1
                        [sum_sas, sum_sas_2, num_sas] = initialize_arrays( along_scan_sep);
                        [sum_sat, sum_sat_2, num_sat] = initialize_arrays( along_track_sep);
                    else
                        [sum_sas, sum_sas_2, num_sas] = increment_arrays( along_scan_sep, sum_sas, sum_sas_2, num_sas);
                        [sum_sat, sum_sat_2, num_sat] = increment_arrays( along_track_sep, sum_sat, sum_sat_2, num_sat);
                    end
                    
                    %% Now get the angle the scan line makes counterclockwise from east for each pixel location.
                    
                    % Get the angles for this orbit based on steps of 3
                    % pixels along-scan and replicate first and last
                    % columns to generate an array the same side as the
                    % input lat, lon arrays.
                    
                    az3 = azimuth( latitude(1:end-2,:), longitude(1:end-2,:), latitude(3:end,:), longitude(3:end,:));
                    az1_3 = [az3(1,:); az3; az3(end,:)];
                    
                    nn = find(isnan(az1_3));
                    if iFile==1
                        [sum_az, sum_az_2, num_az] = initialize_arrays( az1_3);
                    else
                        [sum_az, sum_az_2, num_az] = increment_arrays( az1_3, sum_az, sum_az_2, num_az);
                    end
                    
                    %% Save the basics for this orbit.
                    
                    kk = strfind( fi_orbit, '_2011');

% % %                     file_out = ['/Volumes/Aqua-1/Fronts/Temporary_Separation_Files/' fi_orbit(61:75) '_new_separations_and_angles.mat'];
                    file_out = ['/Volumes/Aqua-1/Fronts/Temporary_Separation_Files/' fi_orbit(kk+1:kk+15) '_new_separations_and_angles.mat'];
                    
                    save(file_out, ...
                        'base_dir_orbital_data', 'longitude', 'latitude', ...
                        'along_scan_sep', 'along_track_sep',...
                        'az1_3', 'sum_az', 'sum_az_2', 'num_az', '-v7.3')
                end
            end
        end
    end
    
    % Now get the mean and standard deviation of the angle.
    
    mean_az = sum_az ./ num_az;
    variance = sum_az_2./num_az - mean_az.^2;
    nn = find(variance < 0);
    variance(nn) = nan;
    sigma_az = sqrt(variance);
    
    % Smooth in the along-scan direction using movmedian in smoothdata.
    
    mean_az_final = 450 - smoothdata( mean_az, 1, 'movmedian', 11);
    mean_az_final(mean_az_final>360) = mean_az_final(mean_az_final>360) - 360;
    
    % Get mean and standard deviation of along-track and along-scan separations.
    
    mean_sas = sum_sas ./ num_sas;
    
    variance = sum_sas_2./num_sas - mean_sas.^2;
    nn = find(variance < 0);
    variance(nn) = nan;
    sigma_sas = sqrt(variance);
    
    mean_sat = sum_sat ./ num_sat;
    
    variance = sum_sat_2./num_sat - mean_sat.^2;
    nn = find(variance < 0);
    variance(nn) = nan;
    sigma_sat = sqrt(variance);
    
    % Save the summary stats for this collection of orbits.
    
    % Get the nadir track
    
    lat_nadir = latitude(floor(end/2),:);
    lon_nadir = longitude(floor(end/2),:);
    
    save( seps_and_angles_filename_1, 'lat_nadir', 'lon_nadir', 'mean_az', 'mean_az_final', 'mean_sas', 'mean_sat', 'sigma_*', '-v7.3')
    
else  % Here if the 1st iteration was done previously so just loading the previous version now.
    fprintf('\n ***********************************************************\n Reading First Iteration Output ****************************\n ***********************************************************\n\n')
    load(seps_and_angles_filename_1)
end

%% Now do 2nd iteration for separations.

seps_and_angles_filename_2 = [base_dir_output_data 'Data/mean_seps_and_angles_pass_2.mat'];

if do_second_iteration
    
    fprintf('\n ***********************************************************\n Doing Second iteration ************************************\n ***********************************************************\n\n')
    
    scan_sep_threshold = [5.5 0.3 0.02];
    track_sep_threshold = [1.5 0.3 0.02];
    
    clear sum_* num_*
    
    % Get the list of files already processed.
    
    file_list = dir('/Volumes/Aqua-1/Fronts/Temporary_Separation_Files/*new*separations_and_angles*');
    
    % Loop over orbits on the list.
    
    for iFile=1:length(file_list)
        
        tic
        file_in = [file_list(iFile).folder '/' file_list(iFile).name];
        fprintf('Working on %s\n', file_in)
        
        a = load(file_in);
        
        along_scan_sep = cleanup_arrays( a.along_scan_sep, mean_sas, scan_sep_threshold);
        along_track_sep = cleanup_arrays( a.along_track_sep, mean_sat, track_sep_threshold);
        
        if iFile == 1
            [sum_sas, sum_sas_2, num_sas] = initialize_arrays( along_scan_sep);
            [sum_sat, sum_sat_2, num_sat] = initialize_arrays( along_track_sep);
        else
            [sum_sas, sum_sas_2, num_sas] = increment_arrays( along_scan_sep, sum_sas, sum_sas_2, num_sas);
            [sum_sat, sum_sat_2, num_sat] = increment_arrays( along_track_sep, sum_sat, sum_sat_2, num_sat);
        end
    end
    
    % Get mean and standard deviation of along-track and along-scan separations.
    
    mean_sas = sum_sas ./ num_sas;
    
    variance = sum_sas_2./num_sas - mean_sas.^2;
    nn = find(variance < 0);
    variance(nn) = nan;
    sigma_sas = sqrt(variance);
    
    mean_sat = sum_sat ./ num_sat;
    
    variance = sum_sat_2./num_sat - mean_sat.^2;
    nn = find(variance < 0);
    variance(nn) = nan;
    sigma_sat = sqrt(variance);
    
    % Save the summary stats for this collection of orbits.
    
    save( seps_and_angles_filename_2, 'file_list', 'lat_nadir', 'lon_nadir', 'mean_az', 'mean_az_final', 'mean_sas', 'mean_sat', 'sigma_*', '-v7.3')
    
else  % Here if the 2nd iteration was done previously so just loading the previous version now.
    fprintf('\n ***********************************************************\n Reading Second Iteration Output ***************************\n ***********************************************************\n\n')
    load(seps_and_angles_filename_2)
end

% % % %% Use the following orbit as the test orbit.
% % %
% % % if get_test_orbit_data
% % %
% % %     fprintf('\n ***********************************************************\n Doing Test Orbit ************************************\n ***********************************************************\n\n')
% % %
% % %     fi_orbit_1 = '/Volumes/Aqua-1/Fronts/MODIS_Aqua_L2/SST/2010/06/AQUA_MODIS.20100601T021010.L2.SST.nc4';
% % %     index_1_equator_a = 11146; % a for ascending.
% % %     index_1_m58_a = 4500;  % scan line will cross the international date line 180 E.
% % %     index_1_p35_a = 15074;
% % %     index_2_81p86 = 21172; % Highest latitude in orbit.
% % %     index_1_equator_d = 31198; % d for descending.
% % %     index_1_p35_d = 27271;
% % %
% % %     % Get the latitude and longitude for this orbit. The latitude of other
% % %     % orbits should be the same. The longitudes should be these longitudes
% % %     % offset by the differences in ascending equatorial crossings.
% % %
% % %     latitude = ncread( fi_orbit_1, 'regridded_latitude');
% % %     longitude = ncread( fi_orbit_1, 'regridded_longitude');
% % %
% % %     % pixels from nadir for calculations and plots.
% % %
% % %     [num_elements_per_along_scan num_along_scans] = size(longitude);
% % %     pixels_from_nadir = [-num_elements_per_along_scan/2:num_elements_per_along_scan/2 - 1]';
% % %
% % % end

if do_final_smoothing
    
    fprintf('\n ***********************************************************\n Doing Final Smoothing *************************************\n ***********************************************************\n\n')
    
    % Get the longitude and latitude of the test orbit. Will use these as
    % the canonical values of longitude and latitude.
    
% % %     fi_orbit_1 = [base_dir_ancillary_data 'Data/AQUA_MODIS.20100601T021010.L2.SST.nc4'];
    % % % fi_orbit_1 = [base_dir_orbital_data '01/AQUA_MODIS_orbit_40757_20100101T002621_L2_SST.nc4'];
    fi_orbit_1 = [base_dir_orbital_data '02/AQUA_MODIS_orbit_046525_20110201T005330_L2_SST.nc4'];
    latitude = ncread( fi_orbit_1, 'regridded_latitude');
    longitude = ncread( fi_orbit_1, 'regridded_longitude');
    
    % Get the dimensions of the basic fields and make sure they agree.
    
    [num_elements_per_along_scan num_along_scans] = size(longitude);
    pixels_from_nadir = [-num_elements_per_along_scan/2:num_elements_per_along_scan/2 - 1]';
    
    if num_along_scans ~= size(mean_sas,2)
        keyboard % Should never get here.
    end
    
    % Now average over all scan lines that don't seem to have problems but
    % first we need to figure out which ones do have problems. To do this,
    % average over ALL scans and subtract this average from the matrix of all
    % scans and look at the plots.
    
    along_scan_seps_1st = mean(mean_sas, 2, 'omitnan');
    
    % Now get the improved mean scan line separations excluding the scan lines
    % that appear to be problematic. I did this by getting the range of areas
    % where there differences were large in the above plot.
    
    good_scans = [1566:20210, 22130:num_along_scans];
    
    along_scan_seps = mean(mean_sas(:,good_scans), 2, 'omitnan');
    along_track_seps = mean(mean_sat(:,good_scans), 2, 'omitnan');
    
    % Now determine how separations vary with scan line. This is done by
    % finding the factor multiplied by the mean separation that best fits the
    % separation for a given scan line in a least squares sense.
    
    clear sum_sq_diff* min_sum_sq_diff* min_factor*
    
    %% Loop over scans.
    
    for j=1:num_along_scans
        
        % Next loop over factor to multiply the separations for the average
        % scan line to find the closes to the given scan line.
        
        ii = 0;
        for iFactor=0.9:0.0005:1.1
            ii = ii + 1;
            rms_along_scan_diff(ii) = sqrt(sum((mean_sas(:,j) - iFactor * along_scan_seps).^2,'omitnan')) / num_elements_per_along_scan;
            rms_along_track_diff(ii) = sqrt(sum((mean_sat(:,j) - iFactor * along_track_seps).^2,'omitnan')) / num_elements_per_along_scan;
        end
        
        % And find the factor yielding the smallest sum of squared differences.
        
        nn = find(min(rms_along_scan_diff) == rms_along_scan_diff);
        
        min_rms_along_scan_diff(j) = rms_along_scan_diff(nn(1));
        min_along_scan_factor(j) = 0.9 + (nn(1) - 1) * 0.0005;
        
        mm = find(min(rms_along_track_diff) == rms_along_track_diff);
        
        min_rms_along_track_diff(j) = rms_along_track_diff(mm(1));
        min_along_track_factor(j) = 0.9 + (mm(1) - 1) * 0.0005;
    end
    
    % And smooth the factors to, well, clean them up a bit.
    
    smoothed_min_along_scan_factor = smoothdata(min_along_scan_factor, 'gaussian', 1000);
    smoothed_min_along_track_factor = smoothdata(min_along_track_factor, 'gaussian', 1000);
    
    % So to get the separation of pixels along a scan line for a given scan
    % line, multiple the mean separations by the factor.
    
    %% And the distance from nadir to each point on the scan line.
    
    along_scan_locs = cumsum(along_scan_seps);
    along_scan_locs = along_scan_locs - along_scan_locs(floor(end/2));
    
    save([base_dir_output_data 'Data/auxillary_seps_and_angles.mat'], 'along_scan_seps_1st', 'along_scan_seps', ...
        'along_track_seps', 'rms_along_scan_diff', 'rms_along_track_diff', 'min_rms_along_scan_diff', 'min_rms_along_track_diff', 'min_along_scan_factor', ...
        'min_along_track_factor', 'smoothed_min_along_scan_factor', 'smoothed_min_along_track_factor', 'along_scan_locs', 'longitude', 'latitude', ...
        'num_elements_per_along_scan', 'num_along_scans', 'pixels_from_nadir')
else
    fprintf('\n ***********************************************************\n Reading Final Smoothing Output ****************************\n ***********************************************************\n\n')
    load([base_dir_output_data 'Data/auxillary_seps_and_angles.mat'])
end

if write_netCDF_file
    [Status, along_scan_seps_array, along_track_seps_array] = ...
        write_sep_and_angle_arrays( output_filename, file_list, longitude, latitude, mean_az_final, ...
        along_scan_seps, along_track_seps, min_along_scan_factor, min_along_track_factor, ...
        smoothed_min_along_scan_factor, smoothed_min_along_track_factor);
end

diary off