function [SST_Out] = fast_interpolate_SST_linear( weights, locations, SST_In)
% fast_interpolate_SST_linear - interpolate to regridded orbit - PCC
%  
% This function will regrid an input array based on a set of weights and
% locations. For each pixel location of the output array, the locations
% identify the pixels in the input array contributing to the SST at the
% output location and the weights, how much to weight the input SST at
% those locations. 
%
% weights and locations are generated by another script. The idea is to do
% it for entire orbits. Since the relationship between latitudes and
% longitudes remains the same for all orbits, the weights and locations
% should be the same.
%
% INPUT
%   weights - 3d array of weights, the 1st dimension is for the number of
%    weights at a given pixel location. These weights correspond to the
%    weights to use in regridding from the input pixels contributing to the
%    output pixel at an output location.
%   locations - the locations of the input pixels contributing to the
%    output pixel at each output location. The location number are the
%    index of the input array as a 1d vector.
%   SST_In - is the SST of the input field.
%
% OUTPUT
%   SST_Out - is the regridded SST.
%
% EXAMPLE: 
%   fi_orbit = '/Volumes/Aqua-1/Fronts/MODIS_Aqua_L2/SST/2010/07/AQUA_MODIS.20100701T004317.L2.SST.nc4';
%   SST_In = ncread(fi_orbit, 'SST_In');
%   [SST_Out] = fast_interpolate_SST_linear( weights, locations, SST_In);
%

[nElements, nScans] = size(SST_In);
[nMax, mElements, mScans] = size(weights);

% Check number of elements/scan line; should be the same for weights and sst.

if mElements > nElements
    fprintf('\n\n****************\nNumber of weight elements/scan (%i) is not equal to the number of SST elements/scans (%i).\n****************\n\n ', mElements, nElements)
    
    regridded_sst = [];
    return
end

% Make sure that there are more weight scan lines than SST scan lines.

if mScans < nScans
    fprintf('\n\n****************\nNumber of weight scans (%i) is less than the number of SST scans (%i).\n****************\n\n ', mScans, nScans)
    
    regridded_sst = [];
    return
end

% Now regrid.

SST_Out = zeros([nElements, nScans]);

for iC=1:nMax
    weights_temp = squeeze(weights(iC,:,:));
    
    mm = find(weights_temp(:) ~= 0);
    
    if length(mm) > 0
        locations_temp = squeeze(locations(iC,:,:));
    
        good_weights = find( (weights_temp ~= 0) & (locations_temp ~= 0));
        tt = locations_temp(good_weights);
        
        SST_Out(good_weights) = SST_Out(good_weights) + SST_In(tt) .* weights_temp(good_weights);
    end
end

% Now set all pixels with nan as weights to nan, they are zero at this
% point, which screws up calculations of gradients.

nan_weights = find(isnan(weights_temp) == 1);
SST_Out(nan_weights) = nan;
